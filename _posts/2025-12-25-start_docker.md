---
title: "[Docker] 01-Docker 시작하기"
categories: [DevOps, Container]
tags: [DevOps, Container, Docker]
---

# Docker 시작하기

Docker는 애플리케이션을 **컨테이너(Container)**라는 격리된 환경에서 실행할 수 있게 해주는 플랫폼이다. 컨테이너는 가상 머신(VM)보다 가볍고 빠르며, 자체적인 파일 시스템과 네트워크를 갖추고 있어 어떤 환경에서도 동일하게 동작하는 이식성을 보장한다.

## 기존 애플리케이션 환경의 한계

전통적인 애플리케이션은 대부분 **모노리식(Monolithic) 아키텍처**로 설계되었다. 모든 기능이 하나의 거대한 코드 베이스에 통합된 이 방식은 다음과 같은 치명적인 단점이 있다.
- **낮은 확장성**: 특정 기능에 트래픽이 몰려도 전체 애플리케이션을 확장(Scale-out)해야 하므로 자원 낭비가 심하다.
- **유지보수의 어려움**: 코드의 의존성이 복잡하여 작은 수정이 전체 시스템에 영향을 줄 수 있다.

이러한 애플리케이션을 클라우드로 이주할 때, 기존에는 주로 다음과 같은 선택지가 고려되었다.
- **IaaS (Infrastructure as a Service)**: 가상 머신(VM) 위에 애플리케이션을 그대로 올리는 방식.
  - 이주 과정은 간단하지만, VM의 오버헤드로 인해 클라우드의 비용 효율성을 100% 활용하기 어렵다.
- **PaaS (Platform as a Service)**: 애플리케이션을 클라우드 공급자가 제공하는 관리형 런타임에 맞춰 재작성하는 방식.
  - 운영 효율성은 높지만, 특정 플랫폼에 종속(Lock-in)되거나 이주를 위한 코드 수정 비용이 크다.

## Docker를 활용한 마이크로서비스 전략
 
Docker는 IaaS의 유연성과 PaaS의 효율성을 동시에 제공하며, 다음과 같은 과정을 통해 **마이크로서비스 아키텍처(MSA)** 구축을 돕는다.
1. **컨테이너화**: 각 기능을 독립된 컨테이너로 격리. 각 컨테이너는 독립적인 데이터 저장소를 가질 수 있으며, 명확히 정의된 API를 통해서만 통신.
2. **패키징 및 정의**: `Dockerfile`로 실행 환경을 이미지로 패키징하고, `Docker Compose`를 통해 다중 컨테이너 애플리케이션의 구성을 정의.

Docker를 도입한다고 해서 모노리식 코드가 즉시 분산 시스템으로 변하는 것은 아니다. 하지만 Docker는 기존 레거시 시스템을 수정 없이 컨테이너에 담아 운영하면서, 새로운 기능을 별도의 마이크로서비스 컨테이너로 추가하는 전략을 가능하게 한다.
- **기술 스택의 유연성**: 새로 추가되는 기능은 기존 코드와 완전히 다른 언어나 프레임워크를 사용하여 별도의 컨테이너로 개발할 수 있다.
- **라우팅을 통한 분리**: 앞단에 API 게이트웨이(라우팅 컴포넌트)를 두어 트래픽을 제어함으로써, 기존 모노리식 시스템의 기능을 하나씩 새로운 마이크로서비스로 대체해 나갈 수 있다.

## Docke를 통한 클라우드 네이티브로의 진화

Docker를 통해 애플리케이션을 컨테이너화하면, Kubernetes와 같은 오케스트레이션 도구를 통해 클러스터 단위로 전체 시스템을 관리할 수 있게 된다. 이는 가상 머신처럼 독립적이면서도 PaaS처럼 가볍고 효율적이다.

**클라우드 네이티브 컴퓨팅 재단(CNCF)**은 이러한 현대적인 아키텍처의 특징을 다음과 같이 정의한다.
- **컨테이너화**: 각 프로세스를 자체 컨테이너로 패키징하여 배포.
- **동적 관리**: 컨테이너 오케스트레이션을 통해 리소스 사용을 최적화하고 자동화.
- **마이크로서비스**: 애플리케이션을 느슨하게 결합된 서비스의 집합으로 구축하여, 유지보수성과 확장성을 극대화.
